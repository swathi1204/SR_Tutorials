{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FindOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_concern_1 = require(\"../read_concern\");\nconst sort_1 = require(\"../sort\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass FindOperation extends command_1.CommandOperation {\n  constructor(collection, ns) {\n    let filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(collection, options);\n    this.options = options;\n    this.ns = ns;\n    if (typeof filter !== 'object' || Array.isArray(filter)) {\n      throw new error_1.MongoInvalidArgumentError('Query filter must be a plain object or ObjectId');\n    }\n    // If the filter is a buffer, validate that is a valid BSON document\n    if (Buffer.isBuffer(filter)) {\n      const objectSize = filter[0] | filter[1] << 8 | filter[2] << 16 | filter[3] << 24;\n      if (objectSize !== filter.length) {\n        throw new error_1.MongoInvalidArgumentError(`Query filter raw message size does not match message header size [${filter.length}] != [${objectSize}]`);\n      }\n    }\n    // special case passing in an ObjectId as a filter\n    this.filter = filter != null && filter._bsontype === 'ObjectID' ? {\n      _id: filter\n    } : filter;\n  }\n  execute(server, session, callback) {\n    this.server = server;\n    const options = this.options;\n    let findCommand = makeFindCommand(this.ns, this.filter, options);\n    if (this.explain) {\n      findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);\n    }\n    server.command(this.ns, findCommand, {\n      ...this.options,\n      ...this.bsonOptions,\n      documentsReturnedIn: 'firstBatch',\n      session\n    }, callback);\n  }\n}\nexports.FindOperation = FindOperation;\nfunction makeFindCommand(ns, filter, options) {\n  const findCommand = {\n    find: ns.collection,\n    filter\n  };\n  if (options.sort) {\n    findCommand.sort = (0, sort_1.formatSort)(options.sort);\n  }\n  if (options.projection) {\n    let projection = options.projection;\n    if (projection && Array.isArray(projection)) {\n      projection = projection.length ? projection.reduce((result, field) => {\n        result[field] = 1;\n        return result;\n      }, {}) : {\n        _id: 1\n      };\n    }\n    findCommand.projection = projection;\n  }\n  if (options.hint) {\n    findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);\n  }\n  if (typeof options.skip === 'number') {\n    findCommand.skip = options.skip;\n  }\n  if (typeof options.limit === 'number') {\n    if (options.limit < 0) {\n      findCommand.limit = -options.limit;\n      findCommand.singleBatch = true;\n    } else {\n      findCommand.limit = options.limit;\n    }\n  }\n  if (typeof options.batchSize === 'number') {\n    if (options.batchSize < 0) {\n      if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {\n        findCommand.limit = -options.batchSize;\n      }\n      findCommand.singleBatch = true;\n    } else {\n      findCommand.batchSize = options.batchSize;\n    }\n  }\n  if (typeof options.singleBatch === 'boolean') {\n    findCommand.singleBatch = options.singleBatch;\n  }\n  // we check for undefined specifically here to allow falsy values\n  // eslint-disable-next-line no-restricted-syntax\n  if (options.comment !== undefined) {\n    findCommand.comment = options.comment;\n  }\n  if (typeof options.maxTimeMS === 'number') {\n    findCommand.maxTimeMS = options.maxTimeMS;\n  }\n  const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n  if (readConcern) {\n    findCommand.readConcern = readConcern.toJSON();\n  }\n  if (options.max) {\n    findCommand.max = options.max;\n  }\n  if (options.min) {\n    findCommand.min = options.min;\n  }\n  if (typeof options.returnKey === 'boolean') {\n    findCommand.returnKey = options.returnKey;\n  }\n  if (typeof options.showRecordId === 'boolean') {\n    findCommand.showRecordId = options.showRecordId;\n  }\n  if (typeof options.tailable === 'boolean') {\n    findCommand.tailable = options.tailable;\n  }\n  if (typeof options.oplogReplay === 'boolean') {\n    findCommand.oplogReplay = options.oplogReplay;\n  }\n  if (typeof options.timeout === 'boolean') {\n    findCommand.noCursorTimeout = !options.timeout;\n  } else if (typeof options.noCursorTimeout === 'boolean') {\n    findCommand.noCursorTimeout = options.noCursorTimeout;\n  }\n  if (typeof options.awaitData === 'boolean') {\n    findCommand.awaitData = options.awaitData;\n  }\n  if (typeof options.allowPartialResults === 'boolean') {\n    findCommand.allowPartialResults = options.allowPartialResults;\n  }\n  if (options.collation) {\n    findCommand.collation = options.collation;\n  }\n  if (typeof options.allowDiskUse === 'boolean') {\n    findCommand.allowDiskUse = options.allowDiskUse;\n  }\n  if (options.let) {\n    findCommand.let = options.let;\n  }\n  return findCommand;\n}\n(0, operation_1.defineAspects)(FindOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);\n//# sourceMappingURL=find.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}