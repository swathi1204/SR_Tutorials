{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"./bson\");\nconst change_stream_1 = require(\"./change_stream\");\nconst connection_string_1 = require(\"./connection_string\");\nconst constants_1 = require(\"./constants\");\nconst db_1 = require(\"./db\");\nconst error_1 = require(\"./error\");\nconst mongo_logger_1 = require(\"./mongo_logger\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst read_preference_1 = require(\"./read_preference\");\nconst server_selection_1 = require(\"./sdam/server_selection\");\nconst topology_1 = require(\"./sdam/topology\");\nconst sessions_1 = require(\"./sessions\");\nconst utils_1 = require(\"./utils\");\n/** @public */\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedence over the URI options.\n *\n * @example\n * ```ts\n * import { MongoClient } from 'mongodb';\n *\n * // Enable command monitoring for debugging\n * const client = new MongoClient('mongodb://localhost:27017', { monitorCommands: true });\n *\n * client.on('commandStarted', started => console.log(started));\n * client.db().collection('pets');\n * await client.insertOne({ name: 'spot', kind: 'dog' });\n * ```\n */\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n  constructor(url, options) {\n    super();\n    this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);\n    this.mongoLogger = new mongo_logger_1.MongoLogger(this[kOptions].mongoLoggerOptions);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const client = this;\n    // The internal state\n    this.s = {\n      url,\n      bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),\n      namespace: (0, utils_1.ns)('admin'),\n      hasBeenClosed: false,\n      sessionPool: new sessions_1.ServerSessionPool(this),\n      activeSessions: new Set(),\n      get options() {\n        return client[kOptions];\n      },\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n      get logger() {\n        return client[kOptions].logger;\n      },\n      get isMongoClient() {\n        return true;\n      }\n    };\n  }\n  get options() {\n    return Object.freeze({\n      ...this[kOptions]\n    });\n  }\n  get serverApi() {\n    return this[kOptions].serverApi && Object.freeze({\n      ...this[kOptions].serverApi\n    });\n  }\n  /**\n   * Intended for APM use only\n   * @internal\n   */\n  get monitorCommands() {\n    return this[kOptions].monitorCommands;\n  }\n  set monitorCommands(value) {\n    this[kOptions].monitorCommands = value;\n  }\n  get autoEncrypter() {\n    return this[kOptions].autoEncrypter;\n  }\n  get readConcern() {\n    return this.s.readConcern;\n  }\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n  get readPreference() {\n    return this.s.readPreference;\n  }\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  get logger() {\n    return this.s.logger;\n  }\n  connect(callback) {\n    var _this = this;\n    if (callback && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n    }\n    return (0, utils_1.maybeCallback)(async () => {\n      if (this.topology && this.topology.isConnected()) {\n        return this;\n      }\n      const options = this[kOptions];\n      if (typeof options.srvHost === 'string') {\n        const hosts = await (0, connection_string_1.resolveSRVRecord)(options);\n        for (const [index, host] of hosts.entries()) {\n          options.hosts[index] = host;\n        }\n      }\n      const topology = new topology_1.Topology(options.hosts, options);\n      // Events can be emitted before initialization is complete so we have to\n      // save the reference to the topology on the client ASAP if the event handlers need to access it\n      this.topology = topology;\n      topology.client = this;\n      topology.once(topology_1.Topology.OPEN, () => this.emit('open', this));\n      for (const event of constants_1.MONGO_CLIENT_EVENTS) {\n        topology.on(event, function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          return _this.emit(event, ...args);\n        });\n      }\n      const topologyConnect = async () => {\n        try {\n          await (0, util_1.promisify)(callback => topology.connect(options, callback))();\n        } catch (error) {\n          topology.close({\n            force: true\n          });\n          throw error;\n        }\n      };\n      if (this.autoEncrypter) {\n        const initAutoEncrypter = (0, util_1.promisify)(callback => {\n          var _a;\n          return (_a = this.autoEncrypter) === null || _a === void 0 ? void 0 : _a.init(callback);\n        });\n        await initAutoEncrypter();\n        await topologyConnect();\n        await options.encrypter.connectInternalClient();\n      } else {\n        await topologyConnect();\n      }\n      return this;\n    }, callback);\n  }\n  close(forceOrCallback, callback) {\n    // There's no way to set hasBeenClosed back to false\n    Object.defineProperty(this.s, 'hasBeenClosed', {\n      value: true,\n      enumerable: true,\n      configurable: false,\n      writable: false\n    });\n    if (typeof forceOrCallback === 'function') {\n      callback = forceOrCallback;\n    }\n    const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n    return (0, utils_1.maybeCallback)(async () => {\n      const activeSessionEnds = Array.from(this.s.activeSessions, session => session.endSession());\n      this.s.activeSessions.clear();\n      await Promise.all(activeSessionEnds);\n      if (this.topology == null) {\n        return;\n      }\n      // If we would attempt to select a server and get nothing back we short circuit\n      // to avoid the server selection timeout.\n      const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);\n      const topologyDescription = this.topology.description;\n      const serverDescriptions = Array.from(topologyDescription.servers.values());\n      const servers = selector(topologyDescription, serverDescriptions);\n      if (servers.length !== 0) {\n        const endSessions = Array.from(this.s.sessionPool.sessions, _ref => {\n          let {\n            id\n          } = _ref;\n          return id;\n        });\n        if (endSessions.length !== 0) {\n          await this.db('admin').command({\n            endSessions\n          }, {\n            readPreference: read_preference_1.ReadPreference.primaryPreferred,\n            noResponse: true\n          }).catch(() => null); // outcome does not matter\n        }\n      }\n      // clear out references to old topology\n      const topology = this.topology;\n      this.topology = undefined;\n      await new Promise((resolve, reject) => {\n        topology.close({\n          force\n        }, error => {\n          if (error) return reject(error);\n          const {\n            encrypter\n          } = this[kOptions];\n          if (encrypter) {\n            return encrypter.close(this, force, error => {\n              if (error) return reject(error);\n              resolve();\n            });\n          }\n          resolve();\n        });\n      });\n    }, callback);\n  }\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n  db(dbName, options) {\n    options = options !== null && options !== void 0 ? options : {};\n    // Default to db from connection string if not provided\n    if (!dbName) {\n      dbName = this.options.dbName;\n    }\n    // Copy the options and add out internal override of the not shared flag\n    const finalOptions = Object.assign({}, this[kOptions], options);\n    // Return the db object\n    const db = new db_1.Db(this, dbName, finalOptions);\n    // Return the database\n    return db;\n  }\n  static connect(url, options, callback) {\n    callback = typeof callback === 'function' ? callback : typeof options === 'function' ? options : undefined;\n    return (0, utils_1.maybeCallback)(async () => {\n      options = typeof options !== 'function' ? options : undefined;\n      const client = new this(url, options);\n      return client.connect();\n    }, callback);\n  }\n  startSession(options) {\n    const session = new sessions_1.ClientSession(this, this.s.sessionPool, {\n      explicit: true,\n      ...options\n    }, this[kOptions]);\n    this.s.activeSessions.add(session);\n    session.once('ended', () => {\n      this.s.activeSessions.delete(session);\n    });\n    return session;\n  }\n  withSession(optionsOrOperation, callback) {\n    const options = {\n      // Always define an owner\n      owner: Symbol(),\n      // If it's an object inherit the options\n      ...(typeof optionsOrOperation === 'object' ? optionsOrOperation : {})\n    };\n    const withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;\n    if (withSessionCallback == null) {\n      throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n    }\n    const session = this.startSession(options);\n    return (0, utils_1.maybeCallback)(async () => {\n      try {\n        await withSessionCallback(session);\n      } finally {\n        try {\n          await session.endSession();\n        } catch {\n          // We are not concerned with errors from endSession()\n        }\n      }\n    }, null);\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct use cases:\n   * - The first is to provide the schema that may be defined for all the data within the current cluster\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TSchema - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n  watch() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /** Return the mongo client logger */\n  getLogger() {\n    return this.s.logger;\n  }\n}\nexports.MongoClient = MongoClient;\n//# sourceMappingURL=mongo_client.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}