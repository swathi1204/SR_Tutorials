{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst common_functions_1 = require(\"./common_functions\");\nconst operation_1 = require(\"./operation\");\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version',\n// text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion',\n// 2d-sphere indexes\n'2dsphereIndexVersion',\n// 2d indexes\n'bits', 'min', 'max',\n// geoHaystack Indexes\n'bucketSize',\n// wildcard indexes\n'wildcardProjection']);\nfunction isIndexDirection(x) {\n  return typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack';\n}\nfunction isSingleIndexTuple(t) {\n  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);\n}\nfunction makeIndexSpec(indexSpec, options) {\n  var _a;\n  const key = new Map();\n  const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;\n  // Iterate through array and handle different types\n  for (const spec of indexSpecs) {\n    if (typeof spec === 'string') {\n      key.set(spec, 1);\n    } else if (Array.isArray(spec)) {\n      key.set(spec[0], (_a = spec[1]) !== null && _a !== void 0 ? _a : 1);\n    } else if (spec instanceof Map) {\n      for (const [property, value] of spec) {\n        key.set(property, value);\n      }\n    } else if ((0, utils_1.isObject)(spec)) {\n      for (const [property, value] of Object.entries(spec)) {\n        key.set(property, value);\n      }\n    }\n  }\n  return {\n    ...options,\n    key\n  };\n}\n/** @internal */\nclass IndexesOperation extends operation_1.AbstractOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = this.options;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {\n      full: true,\n      ...options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n}\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\nclass CreateIndexesOperation extends command_1.CommandOperation {\n  constructor(parent, collectionName, indexes, options) {\n    super(parent, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionName = collectionName;\n    this.indexes = indexes.map(userIndex => {\n      // Ensure the key is a Map to preserve index key ordering\n      const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));\n      const name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join('_');\n      const validIndexOptions = Object.fromEntries(Object.entries({\n        ...userIndex\n      }).filter(_ref => {\n        let [optionName] = _ref;\n        return VALID_INDEX_OPTIONS.has(optionName);\n      }));\n      return {\n        ...validIndexOptions,\n        name,\n        key\n      };\n    });\n  }\n  execute(server, session, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const cmd = {\n      createIndexes: this.collectionName,\n      indexes\n    };\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n      cmd.commitQuorum = options.commitQuorum;\n    }\n    // collation is set on each index, it should not be defined at the root\n    this.options.collation = undefined;\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames);\n    });\n  }\n}\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\nclass CreateIndexOperation extends CreateIndexesOperation {\n  constructor(parent, collectionName, indexSpec, options) {\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n  execute(server, session, callback) {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n}\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\nclass EnsureIndexOperation extends CreateIndexOperation {\n  constructor(db, collectionName, indexSpec, options) {\n    super(db, collectionName, indexSpec, options);\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n  execute(server, session, callback) {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({\n      session\n    });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n      super.execute(server, session, callback);\n    });\n  }\n}\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\nclass DropIndexOperation extends command_1.CommandOperation {\n  constructor(collection, indexName, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n  execute(server, session, callback) {\n    const cmd = {\n      dropIndexes: this.collection.collectionName,\n      index: this.indexName\n    };\n    super.executeCommand(server, session, cmd, callback);\n  }\n}\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\nclass DropIndexesOperation extends DropIndexOperation {\n  constructor(collection, options) {\n    super(collection, '*', options);\n  }\n  execute(server, session, callback) {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n}\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\nclass ListIndexesOperation extends command_1.CommandOperation {\n  constructor(collection, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n  execute(server, session, callback) {\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const cursor = this.options.batchSize ? {\n      batchSize: this.options.batchSize\n    } : {};\n    const command = {\n      listIndexes: this.collectionNamespace.collection,\n      cursor\n    };\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n    super.executeCommand(server, session, command, callback);\n  }\n}\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @internal */\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n  constructor(collection, indexes, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const indexes = this.indexes;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {\n      ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, (err, indexInformation) => {\n      // If we have an error return\n      if (err != null) return callback(err);\n      // Let's check for the index names\n      if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null);\n      // Check in list of indexes\n      for (let i = 0; i < indexes.length; i++) {\n        if (indexInformation[indexes[i]] == null) {\n          return callback(undefined, false);\n        }\n      }\n      // All keys found return true\n      return callback(undefined, true);\n    });\n  }\n}\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n  constructor(db, name, options) {\n    super(options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.name = name;\n  }\n  execute(server, session, callback) {\n    const db = this.db;\n    const name = this.name;\n    (0, common_functions_1.indexInformation)(db, name, {\n      ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n}\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n//# sourceMappingURL=indexes.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}