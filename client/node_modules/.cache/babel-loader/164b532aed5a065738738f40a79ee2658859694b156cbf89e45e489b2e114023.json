{"ast":null,"code":"export const parseBoolean = value => {\n  switch (value) {\n    case \"true\":\n      return true;\n    case \"false\":\n      return false;\n    default:\n      throw new Error(`Unable to parse boolean value \"${value}\"`);\n  }\n};\nexport const expectBoolean = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"number\") {\n    if (value === 0 || value === 1) {\n      logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));\n    }\n    if (value === 0) {\n      return false;\n    }\n    if (value === 1) {\n      return true;\n    }\n  }\n  if (typeof value === \"string\") {\n    const lower = value.toLowerCase();\n    if (lower === \"false\" || lower === \"true\") {\n      logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));\n    }\n    if (lower === \"false\") {\n      return false;\n    }\n    if (lower === \"true\") {\n      return true;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);\n};\nexport const expectNumber = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"string\") {\n    const parsed = parseFloat(value);\n    if (!Number.isNaN(parsed)) {\n      if (String(parsed) !== String(value)) {\n        logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));\n      }\n      return parsed;\n    }\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  throw new TypeError(`Expected number, got ${typeof value}: ${value}`);\n};\nconst MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\nexport const expectFloat32 = value => {\n  const expected = expectNumber(value);\n  if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {\n    if (Math.abs(expected) > MAX_FLOAT) {\n      throw new TypeError(`Expected 32-bit float, got ${value}`);\n    }\n  }\n  return expected;\n};\nexport const expectLong = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (Number.isInteger(value) && !Number.isNaN(value)) {\n    return value;\n  }\n  throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);\n};\nexport const expectInt = expectLong;\nexport const expectInt32 = value => expectSizedInt(value, 32);\nexport const expectShort = value => expectSizedInt(value, 16);\nexport const expectByte = value => expectSizedInt(value, 8);\nconst expectSizedInt = (value, size) => {\n  const expected = expectLong(value);\n  if (expected !== undefined && castInt(expected, size) !== expected) {\n    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);\n  }\n  return expected;\n};\nconst castInt = (value, size) => {\n  switch (size) {\n    case 32:\n      return Int32Array.of(value)[0];\n    case 16:\n      return Int16Array.of(value)[0];\n    case 8:\n      return Int8Array.of(value)[0];\n  }\n};\nexport const expectNonNull = (value, location) => {\n  if (value === null || value === undefined) {\n    if (location) {\n      throw new TypeError(`Expected a non-null value for ${location}`);\n    }\n    throw new TypeError(\"Expected a non-null value\");\n  }\n  return value;\n};\nexport const expectObject = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"object\" && !Array.isArray(value)) {\n    return value;\n  }\n  const receivedType = Array.isArray(value) ? \"array\" : typeof value;\n  throw new TypeError(`Expected object, got ${receivedType}: ${value}`);\n};\nexport const expectString = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if ([\"boolean\", \"number\", \"bigint\"].includes(typeof value)) {\n    logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));\n    return String(value);\n  }\n  throw new TypeError(`Expected string, got ${typeof value}: ${value}`);\n};\nexport const expectUnion = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  const asObject = expectObject(value);\n  const setKeys = Object.entries(asObject).filter(_ref => {\n    let [, v] = _ref;\n    return v != null;\n  }).map(_ref2 => {\n    let [k] = _ref2;\n    return k;\n  });\n  if (setKeys.length === 0) {\n    throw new TypeError(`Unions must have exactly one non-null member. None were found.`);\n  }\n  if (setKeys.length > 1) {\n    throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);\n  }\n  return asObject;\n};\nexport const strictParseDouble = value => {\n  if (typeof value == \"string\") {\n    return expectNumber(parseNumber(value));\n  }\n  return expectNumber(value);\n};\nexport const strictParseFloat = strictParseDouble;\nexport const strictParseFloat32 = value => {\n  if (typeof value == \"string\") {\n    return expectFloat32(parseNumber(value));\n  }\n  return expectFloat32(value);\n};\nconst NUMBER_REGEX = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\nconst parseNumber = value => {\n  const matches = value.match(NUMBER_REGEX);\n  if (matches === null || matches[0].length !== value.length) {\n    throw new TypeError(`Expected real number, got implicit NaN`);\n  }\n  return parseFloat(value);\n};\nexport const limitedParseDouble = value => {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n  return expectNumber(value);\n};\nexport const handleFloat = limitedParseDouble;\nexport const limitedParseFloat = limitedParseDouble;\nexport const limitedParseFloat32 = value => {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n  return expectFloat32(value);\n};\nconst parseFloatString = value => {\n  switch (value) {\n    case \"NaN\":\n      return NaN;\n    case \"Infinity\":\n      return Infinity;\n    case \"-Infinity\":\n      return -Infinity;\n    default:\n      throw new Error(`Unable to parse float value: ${value}`);\n  }\n};\nexport const strictParseLong = value => {\n  if (typeof value === \"string\") {\n    return expectLong(parseNumber(value));\n  }\n  return expectLong(value);\n};\nexport const strictParseInt = strictParseLong;\nexport const strictParseInt32 = value => {\n  if (typeof value === \"string\") {\n    return expectInt32(parseNumber(value));\n  }\n  return expectInt32(value);\n};\nexport const strictParseShort = value => {\n  if (typeof value === \"string\") {\n    return expectShort(parseNumber(value));\n  }\n  return expectShort(value);\n};\nexport const strictParseByte = value => {\n  if (typeof value === \"string\") {\n    return expectByte(parseNumber(value));\n  }\n  return expectByte(value);\n};\nconst stackTraceWarning = message => {\n  return String(new TypeError(message).stack || message).split(\"\\n\").slice(0, 5).filter(s => !s.includes(\"stackTraceWarning\")).join(\"\\n\");\n};\nexport const logger = {\n  warn: console.warn\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}