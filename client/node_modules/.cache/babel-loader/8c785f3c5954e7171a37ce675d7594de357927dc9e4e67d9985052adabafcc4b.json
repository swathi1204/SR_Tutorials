{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\nconst error_1 = require(\"../error\");\nconst write_concern_1 = require(\"../write_concern\");\nconst bulk_write_1 = require(\"./bulk_write\");\nconst command_1 = require(\"./command\");\nconst common_functions_1 = require(\"./common_functions\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass InsertOperation extends command_1.CommandOperation {\n  constructor(ns, documents, options) {\n    var _a;\n    super(undefined, options);\n    this.options = {\n      ...options,\n      checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false\n    };\n    this.ns = ns;\n    this.documents = documents;\n  }\n  execute(server, session, callback) {\n    var _a;\n    const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n    super.executeCommand(server, session, command, callback);\n  }\n}\nexports.InsertOperation = InsertOperation;\nclass InsertOneOperation extends InsertOperation {\n  constructor(collection, doc, options) {\n    super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);\n  }\n  execute(server, session, callback) {\n    super.execute(server, session, (err, res) => {\n      var _a, _b;\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new error_1.MongoServerError(res));\n      if (res.writeErrors) {\n        // This should be a WriteError but we can't change it now because of error hierarchy\n        return callback(new error_1.MongoServerError(res.writeErrors[0]));\n      }\n      callback(undefined, {\n        acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n}\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\nclass InsertManyOperation extends operation_1.AbstractOperation {\n  constructor(collection, docs, options) {\n    super(options);\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = {\n      ...this.options,\n      ...this.bsonOptions,\n      readPreference: this.readPreference\n    };\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(document => ({\n      insertOne: {\n        document\n      }\n    })), options);\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      var _a;\n      if (err || res == null) {\n        if (err && err.message === 'Operation must be an object with an operation key') {\n          err = new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');\n        }\n        return callback(err);\n      }\n      callback(undefined, {\n        acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n}\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);\n//# sourceMappingURL=insert.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}