{"ast":null,"code":"import { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@aws-sdk/service-error-classification\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@aws-sdk/util-retry\";\nimport { v4 } from \"uuid\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = options => (next, context) => async args => {\n  let retryStrategy = await options.retryStrategy();\n  const maxAttempts = await options.maxAttempts();\n  if (isRetryStrategyV2(retryStrategy)) {\n    retryStrategy = retryStrategy;\n    let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n    let lastError = new Error();\n    let attempts = 0;\n    let totalRetryDelay = 0;\n    const {\n      request\n    } = args;\n    if (HttpRequest.isInstance(request)) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n    while (true) {\n      try {\n        if (HttpRequest.isInstance(request)) {\n          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n        const {\n          response,\n          output\n        } = await next(args);\n        retryStrategy.recordSuccess(retryToken);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalRetryDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const retryErrorInfo = getRetyErrorInto(e);\n        lastError = asSdkError(e);\n        try {\n          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n        } catch (refreshError) {\n          if (!lastError.$metadata) {\n            lastError.$metadata = {};\n          }\n          lastError.$metadata.attempts = attempts + 1;\n          lastError.$metadata.totalRetryDelay = totalRetryDelay;\n          throw lastError;\n        }\n        attempts = retryToken.getRetryCount();\n        const delay = retryToken.getRetryDelay();\n        totalRetryDelay += delay;\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  } else {\n    retryStrategy = retryStrategy;\n    if (retryStrategy?.mode) context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n    return retryStrategy.retry(next, args);\n  }\n};\nconst isRetryStrategyV2 = retryStrategy => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" && typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" && typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetyErrorInto = error => {\n  const errorInfo = {\n    errorType: getRetryErrorType(error)\n  };\n  const retryAfterHint = getRetryAfterHint(error.$response);\n  if (retryAfterHint) {\n    errorInfo.retryAfterHint = retryAfterHint;\n  }\n  return errorInfo;\n};\nconst getRetryErrorType = error => {\n  if (isThrottlingError(error)) return \"THROTTLING\";\n  if (isTransientError(error)) return \"TRANSIENT\";\n  if (isServerError(error)) return \"SERVER_ERROR\";\n  return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override: true\n};\nexport const getRetryPlugin = options => ({\n  applyToStack: clientStack => {\n    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n  }\n});\nexport const getRetryAfterHint = response => {\n  if (!HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return new Date(retryAfterSeconds * 1000);\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}