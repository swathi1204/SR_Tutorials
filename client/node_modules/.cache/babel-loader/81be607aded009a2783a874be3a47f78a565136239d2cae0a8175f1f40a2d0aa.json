{"ast":null,"code":"\"use strict\";\n\nconst punycode = require(\"punycode\");\nconst regexes = require(\"./lib/regexes.js\");\nconst mappingTable = require(\"./lib/mappingTable.json\");\nconst {\n  STATUS_MAPPING\n} = require(\"./lib/statusMapping.js\");\nfunction containsNonASCII(str) {\n  return /[^\\x00-\\x7F]/u.test(str);\n}\nfunction findStatus(val, _ref) {\n  let {\n    useSTD3ASCIIRules\n  } = _ref;\n  let start = 0;\n  let end = mappingTable.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const target = mappingTable[mid];\n    const min = Array.isArray(target[0]) ? target[0][0] : target[0];\n    const max = Array.isArray(target[0]) ? target[0][1] : target[0];\n    if (min <= val && max >= val) {\n      if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {\n        return [STATUS_MAPPING.disallowed, ...target.slice(2)];\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {\n        return [STATUS_MAPPING.valid, ...target.slice(2)];\n      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {\n        return [STATUS_MAPPING.mapped, ...target.slice(2)];\n      }\n      return target.slice(1);\n    } else if (min > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return null;\n}\nfunction mapChars(domainName, _ref2) {\n  let {\n    useSTD3ASCIIRules,\n    processingOption\n  } = _ref2;\n  let hasError = false;\n  let processed = \"\";\n  for (const ch of domainName) {\n    const [status, mapping] = findStatus(ch.codePointAt(0), {\n      useSTD3ASCIIRules\n    });\n    switch (status) {\n      case STATUS_MAPPING.disallowed:\n        hasError = true;\n        processed += ch;\n        break;\n      case STATUS_MAPPING.ignored:\n        break;\n      case STATUS_MAPPING.mapped:\n        processed += mapping;\n        break;\n      case STATUS_MAPPING.deviation:\n        if (processingOption === \"transitional\") {\n          processed += mapping;\n        } else {\n          processed += ch;\n        }\n        break;\n      case STATUS_MAPPING.valid:\n        processed += ch;\n        break;\n    }\n  }\n  return {\n    string: processed,\n    error: hasError\n  };\n}\nfunction validateLabel(label, _ref3) {\n  let {\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    processingOption,\n    useSTD3ASCIIRules\n  } = _ref3;\n  if (label.normalize(\"NFC\") !== label) {\n    return false;\n  }\n  const codePoints = Array.from(label);\n  if (checkHyphens) {\n    if (codePoints[2] === \"-\" && codePoints[3] === \"-\" || label.startsWith(\"-\") || label.endsWith(\"-\")) {\n      return false;\n    }\n  }\n  if (label.includes(\".\") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {\n    return false;\n  }\n  for (const ch of codePoints) {\n    const [status] = findStatus(ch.codePointAt(0), {\n      useSTD3ASCIIRules\n    });\n    if (processingOption === \"transitional\" && status !== STATUS_MAPPING.valid || processingOption === \"nontransitional\" && status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {\n      return false;\n    }\n  }\n\n  // https://tools.ietf.org/html/rfc5892#appendix-A\n  if (checkJoiners) {\n    let last = 0;\n    for (const [i, ch] of codePoints.entries()) {\n      if (ch === \"\\u200C\" || ch === \"\\u200D\") {\n        if (i > 0) {\n          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\n            continue;\n          }\n          if (ch === \"\\u200C\") {\n            // TODO: make this more efficient\n            const next = codePoints.indexOf(\"\\u200C\", i + 1);\n            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\n            if (regexes.validZWNJ.test(test.join(\"\"))) {\n              last = i + 1;\n              continue;\n            }\n          }\n        }\n        return false;\n      }\n    }\n  }\n\n  // https://tools.ietf.org/html/rfc5893#section-2\n  if (checkBidi) {\n    let rtl;\n\n    // 1\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\n      rtl = false;\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\n      rtl = true;\n    } else {\n      return false;\n    }\n    if (rtl) {\n      // 2-4\n      if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {\n        return false;\n      }\n    } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {\n      // 5-6\n      return false;\n    }\n  }\n  return true;\n}\nfunction isBidiDomain(labels) {\n  const domain = labels.map(label => {\n    if (label.startsWith(\"xn--\")) {\n      try {\n        return punycode.decode(label.substring(4));\n      } catch (err) {\n        return \"\";\n      }\n    }\n    return label;\n  }).join(\".\");\n  return regexes.bidiDomain.test(domain);\n}\nfunction processing(domainName, options) {\n  const {\n    processingOption\n  } = options;\n\n  // 1. Map.\n  let {\n    string,\n    error\n  } = mapChars(domainName, options);\n\n  // 2. Normalize.\n  string = string.normalize(\"NFC\");\n\n  // 3. Break.\n  const labels = string.split(\".\");\n  const isBidi = isBidiDomain(labels);\n\n  // 4. Convert/Validate.\n  for (const [i, origLabel] of labels.entries()) {\n    let label = origLabel;\n    let curProcessing = processingOption;\n    if (label.startsWith(\"xn--\")) {\n      try {\n        label = punycode.decode(label.substring(4));\n        labels[i] = label;\n      } catch (err) {\n        error = true;\n        continue;\n      }\n      curProcessing = \"nontransitional\";\n    }\n\n    // No need to validate if we already know there is an error.\n    if (error) {\n      continue;\n    }\n    const validation = validateLabel(label, {\n      ...options,\n      processingOption: curProcessing,\n      checkBidi: options.checkBidi && isBidi\n    });\n    if (!validation) {\n      error = true;\n    }\n  }\n  return {\n    string: labels.join(\".\"),\n    error\n  };\n}\nfunction toASCII(domainName) {\n  let {\n    checkHyphens = false,\n    checkBidi = false,\n    checkJoiners = false,\n    useSTD3ASCIIRules = false,\n    processingOption = \"nontransitional\",\n    verifyDNSLength = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (processingOption !== \"transitional\" && processingOption !== \"nontransitional\") {\n    throw new RangeError(\"processingOption must be either transitional or nontransitional\");\n  }\n  const result = processing(domainName, {\n    processingOption,\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n  let labels = result.string.split(\".\");\n  labels = labels.map(l => {\n    if (containsNonASCII(l)) {\n      try {\n        return `xn--${punycode.encode(l)}`;\n      } catch (e) {\n        result.error = true;\n      }\n    }\n    return l;\n  });\n  if (verifyDNSLength) {\n    const total = labels.join(\".\").length;\n    if (total > 253 || total === 0) {\n      result.error = true;\n    }\n    for (let i = 0; i < labels.length; ++i) {\n      if (labels[i].length > 63 || labels[i].length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n  if (result.error) {\n    return null;\n  }\n  return labels.join(\".\");\n}\nfunction toUnicode(domainName) {\n  let {\n    checkHyphens = false,\n    checkBidi = false,\n    checkJoiners = false,\n    useSTD3ASCIIRules = false,\n    processingOption = \"nontransitional\"\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = processing(domainName, {\n    processingOption,\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n  return {\n    domain: result.string,\n    error: result.error\n  };\n}\nmodule.exports = {\n  toASCII,\n  toUnicode\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}