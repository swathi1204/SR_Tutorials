{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.ReturnDocument = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst sort_1 = require(\"../sort\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @public */\nexports.ReturnDocument = Object.freeze({\n  BEFORE: 'before',\n  AFTER: 'after'\n});\nfunction configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {\n  cmdBase.new = options.returnDocument === exports.ReturnDocument.AFTER;\n  cmdBase.upsert = options.upsert === true;\n  if (options.bypassDocumentValidation === true) {\n    cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n  return cmdBase;\n}\n/** @internal */\nclass FindAndModifyOperation extends command_1.CommandOperation {\n  constructor(collection, query, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.cmdBase = {\n      remove: false,\n      new: false,\n      upsert: false\n    };\n    const sort = (0, sort_1.formatSort)(options.sort);\n    if (sort) {\n      this.cmdBase.sort = sort;\n    }\n    if (options.projection) {\n      this.cmdBase.fields = options.projection;\n    }\n    if (options.maxTimeMS) {\n      this.cmdBase.maxTimeMS = options.maxTimeMS;\n    }\n    // Decorate the findAndModify command with the write Concern\n    if (options.writeConcern) {\n      this.cmdBase.writeConcern = options.writeConcern;\n    }\n    if (options.let) {\n      this.cmdBase.let = options.let;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cmdBase.comment = options.comment;\n    }\n    // force primary read preference\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.collection = collection;\n    this.query = query;\n  }\n  execute(server, session, callback) {\n    var _a;\n    const coll = this.collection;\n    const query = this.query;\n    const options = {\n      ...this.options,\n      ...this.bsonOptions\n    };\n    // Create findAndModify command object\n    const cmd = {\n      findAndModify: coll.collectionName,\n      query: query,\n      ...this.cmdBase\n    };\n    // Have we specified collation\n    try {\n      (0, utils_1.decorateWithCollation)(cmd, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n    if (options.hint) {\n      // TODO: once this method becomes a CommandOperation we will have the server\n      // in place to check.\n      const unacknowledgedWrite = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) === 0;\n      if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {\n        callback(new error_1.MongoCompatibilityError('The current topology does not support a hint on findAndModify commands'));\n        return;\n      }\n      cmd.hint = options.hint;\n    }\n    // Execute the command\n    super.executeCommand(server, session, cmd, (err, result) => {\n      if (err) return callback(err);\n      return callback(undefined, result);\n    });\n  }\n}\n/** @internal */\nclass FindOneAndDeleteOperation extends FindAndModifyOperation {\n  constructor(collection, filter, options) {\n    // Basic validation\n    if (filter == null || typeof filter !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n    super(collection, filter, options);\n    this.cmdBase.remove = true;\n  }\n}\nexports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;\n/** @internal */\nclass FindOneAndReplaceOperation extends FindAndModifyOperation {\n  constructor(collection, filter, replacement, options) {\n    if (filter == null || typeof filter !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n    if (replacement == null || typeof replacement !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"replacement\" must be an object');\n    }\n    if ((0, utils_1.hasAtomicOperators)(replacement)) {\n      throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');\n    }\n    super(collection, filter, options);\n    this.cmdBase.update = replacement;\n    configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);\n  }\n}\nexports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;\n/** @internal */\nclass FindOneAndUpdateOperation extends FindAndModifyOperation {\n  constructor(collection, filter, update, options) {\n    if (filter == null || typeof filter !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n    if (update == null || typeof update !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"update\" must be an object');\n    }\n    if (!(0, utils_1.hasAtomicOperators)(update)) {\n      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n    }\n    super(collection, filter, options);\n    this.cmdBase.update = update;\n    configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);\n    if (options.arrayFilters) {\n      this.cmdBase.arrayFilters = options.arrayFilters;\n    }\n  }\n}\nexports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;\n(0, operation_1.defineAspects)(FindAndModifyOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);\n//# sourceMappingURL=find_and_modify.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}