{"ast":null,"code":"import { DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nexport const getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {\n  const MAX_CAPACITY = initialRetryTokens;\n  const retryCost = options?.retryCost ?? RETRY_COST;\n  const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;\n  const retryBackoffStrategy = options?.retryBackoffStrategy ?? getDefaultRetryBackoffStrategy();\n  let availableCapacity = initialRetryTokens;\n  let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);\n  let lastRetryCost = undefined;\n  let retryCount = initialRetryCount ?? 0;\n  const getCapacityAmount = errorType => errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost;\n  const getRetryCount = () => retryCount;\n  const getRetryDelay = () => retryDelay;\n  const getLastRetryCost = () => lastRetryCost;\n  const hasRetryTokens = errorType => getCapacityAmount(errorType) <= availableCapacity;\n  const getRetryTokenCount = errorInfo => {\n    const errorType = errorInfo.errorType;\n    if (!hasRetryTokens(errorType)) {\n      throw new Error(\"No retry token available\");\n    }\n    const capacityAmount = getCapacityAmount(errorType);\n    const delayBase = errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;\n    retryBackoffStrategy.setDelayBase(delayBase);\n    const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\n    if (errorInfo.retryAfterHint) {\n      const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\n      retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\n    } else {\n      retryDelay = delayFromErrorType;\n    }\n    retryCount++;\n    lastRetryCost = capacityAmount;\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n  const releaseRetryTokens = releaseAmount => {\n    availableCapacity += releaseAmount ?? NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n  return {\n    getRetryCount,\n    getRetryDelay,\n    getLastRetryCost,\n    hasRetryTokens,\n    getRetryTokenCount,\n    releaseRetryTokens\n  };\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}