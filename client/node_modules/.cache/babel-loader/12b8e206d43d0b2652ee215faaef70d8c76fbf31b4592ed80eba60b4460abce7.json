{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KillCursorsOperation = void 0;\nconst error_1 = require(\"../error\");\nconst operation_1 = require(\"./operation\");\nclass KillCursorsOperation extends operation_1.AbstractOperation {\n  constructor(cursorId, ns, server, options) {\n    super(options);\n    this.ns = ns;\n    this.cursorId = cursorId;\n    this.server = server;\n  }\n  execute(server, session, callback) {\n    if (server !== this.server) {\n      return callback(new error_1.MongoRuntimeError('Killcursor must run on the same server operation began on'));\n    }\n    const killCursors = this.ns.collection;\n    if (killCursors == null) {\n      // Cursors should have adopted the namespace returned by MongoDB\n      // which should always defined a collection name (even a pseudo one, ex. db.aggregate())\n      return callback(new error_1.MongoRuntimeError('A collection name must be determined before killCursors'));\n    }\n    const killCursorsCommand = {\n      killCursors,\n      cursors: [this.cursorId]\n    };\n    server.command(this.ns, killCursorsCommand, {\n      session\n    }, () => callback());\n  }\n}\nexports.KillCursorsOperation = KillCursorsOperation;\n(0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);\n//# sourceMappingURL=kill_cursors.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}