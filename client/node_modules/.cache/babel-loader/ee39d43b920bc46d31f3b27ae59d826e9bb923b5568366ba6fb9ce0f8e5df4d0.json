{"ast":null,"code":"import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS } from \"./constants\";\nimport { getDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n  constructor(maxAttemptsProvider) {\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);\n    this.maxAttemptsProvider = maxAttemptsProvider;\n  }\n  async acquireInitialRetryToken(retryTokenScope) {\n    return this.retryToken;\n  }\n  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n    const maxAttempts = await this.getMaxAttempts();\n    if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {\n      tokenToRenew.getRetryTokenCount(errorInfo);\n      return tokenToRenew;\n    }\n    throw new Error(\"No retry token available\");\n  }\n  recordSuccess(token) {\n    this.retryToken.releaseRetryTokens(token.getLastRetryCost());\n  }\n  async getMaxAttempts() {\n    let maxAttempts;\n    try {\n      return await this.maxAttemptsProvider();\n    } catch (error) {\n      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n      return DEFAULT_MAX_ATTEMPTS;\n    }\n  }\n  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n    const attempts = tokenToRenew.getRetryCount();\n    return attempts < maxAttempts && tokenToRenew.hasRetryTokens(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);\n  }\n  isRetryableError(errorType) {\n    return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}