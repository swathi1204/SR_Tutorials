{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidateCollectionOperation = void 0;\nconst error_1 = require(\"../error\");\nconst command_1 = require(\"./command\");\n/** @internal */\nclass ValidateCollectionOperation extends command_1.CommandOperation {\n  constructor(admin, collectionName, options) {\n    // Decorate command with extra options\n    const command = {\n      validate: collectionName\n    };\n    const keys = Object.keys(options);\n    for (let i = 0; i < keys.length; i++) {\n      if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== 'session') {\n        command[keys[i]] = options[keys[i]];\n      }\n    }\n    super(admin.s.db, options);\n    this.options = options;\n    this.command = command;\n    this.collectionName = collectionName;\n  }\n  execute(server, session, callback) {\n    const collectionName = this.collectionName;\n    super.executeCommand(server, session, this.command, (err, doc) => {\n      if (err != null) return callback(err);\n      // TODO(NODE-3483): Replace these with MongoUnexpectedServerResponseError\n      if (doc.ok === 0) return callback(new error_1.MongoRuntimeError('Error with validate command'));\n      if (doc.result != null && typeof doc.result !== 'string') return callback(new error_1.MongoRuntimeError('Error with validation data'));\n      if (doc.result != null && doc.result.match(/exception|corrupt/) != null) return callback(new error_1.MongoRuntimeError(`Invalid collection ${collectionName}`));\n      if (doc.valid != null && !doc.valid) return callback(new error_1.MongoRuntimeError(`Invalid collection ${collectionName}`));\n      return callback(undefined, doc);\n    });\n  }\n}\nexports.ValidateCollectionOperation = ValidateCollectionOperation;\n//# sourceMappingURL=validate_collection.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}