{"ast":null,"code":"import { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport { DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, RETRY_MODES, THROTTLING_RETRY_DELAY_BASE } from \"@aws-sdk/util-retry\";\nimport { v4 } from \"uuid\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nimport { asSdkError } from \"./util\";\nexport class StandardRetryStrategy {\n  constructor(maxAttemptsProvider, options) {\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryDecider = options?.retryDecider ?? defaultRetryDecider;\n    this.delayDecider = options?.delayDecider ?? defaultDelayDecider;\n    this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n  }\n  shouldRetry(error, attempts, maxAttempts) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  }\n  async getMaxAttempts() {\n    let maxAttempts;\n    try {\n      maxAttempts = await this.maxAttemptsProvider();\n    } catch (error) {\n      maxAttempts = DEFAULT_MAX_ATTEMPTS;\n    }\n    return maxAttempts;\n  }\n  async retry(next, args, options) {\n    let retryTokenAmount;\n    let attempts = 0;\n    let totalDelay = 0;\n    const maxAttempts = await this.getMaxAttempts();\n    const {\n      request\n    } = args;\n    if (HttpRequest.isInstance(request)) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n    while (true) {\n      try {\n        if (HttpRequest.isInstance(request)) {\n          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n        if (options?.beforeRequest) {\n          await options.beforeRequest();\n        }\n        const {\n          response,\n          output\n        } = await next(args);\n        if (options?.afterRequest) {\n          options.afterRequest(response);\n        }\n        this.retryQuota.releaseRetryTokens(retryTokenAmount);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const err = asSdkError(e);\n        attempts++;\n        if (this.shouldRetry(err, attempts, maxAttempts)) {\n          retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n          const delayFromDecider = this.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n          const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\n          const delay = Math.max(delayFromResponse || 0, delayFromDecider);\n          totalDelay += delay;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        }\n        if (!err.$metadata) {\n          err.$metadata = {};\n        }\n        err.$metadata.attempts = attempts;\n        err.$metadata.totalRetryDelay = totalDelay;\n        throw err;\n      }\n    }\n  }\n}\nconst getDelayFromRetryAfterHeader = response => {\n  if (!HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return retryAfterSeconds * 1000;\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate.getTime() - Date.now();\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}