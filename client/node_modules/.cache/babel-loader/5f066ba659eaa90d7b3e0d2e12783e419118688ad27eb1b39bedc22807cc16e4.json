{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapReduceOperation = void 0;\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\nconst exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation', 'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\nclass MapReduceOperation extends command_1.CommandOperation {\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(collection, map, reduce, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n    const mapCommandHash = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n    if (options.scope) {\n      mapCommandHash.scope = processScope(options.scope);\n    }\n    // Add any other options passed in\n    for (const n in options) {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = options[n];\n      }\n    }\n    options = Object.assign({}, options);\n    // If we have a read preference and inline is not set as output fail hard\n    if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {\n      // Force readPreference to primary\n      options.readPreference = read_preference_1.ReadPreference.primary;\n      // Decorate command with writeConcern if supported\n      (0, utils_1.applyWriteConcern)(mapCommandHash, {\n        db: coll.s.db,\n        collection: coll\n      }, options);\n    } else {\n      (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);\n    }\n    // Is bypassDocumentValidation specified\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    // Have we specified collation\n    try {\n      (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n    if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {\n      callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));\n      return;\n    }\n    // Execute command\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\n      if (err) return callback(err);\n      // Check if we have an error\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return callback(new error_1.MongoServerError(result));\n      }\n      // If an explain option was executed, don't process the server results\n      if (this.explain) return callback(undefined, result);\n      // Create statistics value\n      const stats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing;\n      // invoked with inline?\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(undefined, result.results);\n        }\n        return callback(undefined, {\n          results: result.results,\n          stats: stats\n        });\n      }\n      // The returned collection\n      let collection = null;\n      // If we have an object it's a different db\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result;\n        // Return a collection from another db\n        collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      }\n      // If we wish for no verbosity\n      if (options['verbose'] == null || !options['verbose']) {\n        return callback(err, collection);\n      }\n      // Return stats as third set of values\n      callback(err, {\n        collection,\n        stats\n      });\n    });\n  }\n}\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\nfunction processScope(scope) {\n  if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n  const newScope = {};\n  for (const key of Object.keys(scope)) {\n    if ('function' === typeof scope[key]) {\n      newScope[key] = new bson_1.Code(String(scope[key]));\n    } else if (scope[key]._bsontype === 'Code') {\n      newScope[key] = scope[key];\n    } else {\n      newScope[key] = processScope(scope[key]);\n    }\n  }\n  return newScope;\n}\n(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);\n//# sourceMappingURL=map_reduce.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}