{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreateCollectionOperation = void 0;\nconst collection_1 = require(\"../collection\");\nconst command_1 = require(\"./command\");\nconst indexes_1 = require(\"./indexes\");\nconst operation_1 = require(\"./operation\");\nconst ILLEGAL_COMMAND_FIELDS = new Set(['w', 'wtimeout', 'j', 'fsync', 'autoIndexId', 'pkFactory', 'raw', 'readPreference', 'session', 'readConcern', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation']);\n/** @internal */\nclass CreateCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(db, options);\n    this.options = options;\n    this.db = db;\n    this.name = name;\n  }\n  execute(server, session, callback) {\n    (async () => {\n      var _a, _b, _c, _d, _e, _f;\n      const db = this.db;\n      const name = this.name;\n      const options = this.options;\n      const encryptedFields = (_a = options.encryptedFields) !== null && _a !== void 0 ? _a : (_c = (_b = db.s.client.options.autoEncryption) === null || _b === void 0 ? void 0 : _b.encryptedFieldsMap) === null || _c === void 0 ? void 0 : _c[`${db.databaseName}.${name}`];\n      if (encryptedFields) {\n        // Create auxilliary collections for queryable encryption support.\n        const escCollection = (_d = encryptedFields.escCollection) !== null && _d !== void 0 ? _d : `enxcol_.${name}.esc`;\n        const eccCollection = (_e = encryptedFields.eccCollection) !== null && _e !== void 0 ? _e : `enxcol_.${name}.ecc`;\n        const ecocCollection = (_f = encryptedFields.ecocCollection) !== null && _f !== void 0 ? _f : `enxcol_.${name}.ecoc`;\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          const createOp = new CreateCollectionOperation(db, collectionName, {\n            clusteredIndex: {\n              key: {\n                _id: 1\n              },\n              unique: true\n            }\n          });\n          await createOp.executeWithoutEncryptedFieldsCheck(server, session);\n        }\n        if (!options.encryptedFields) {\n          this.options = {\n            ...this.options,\n            encryptedFields\n          };\n        }\n      }\n      const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);\n      if (encryptedFields) {\n        // Create the required index for queryable encryption support.\n        const createIndexOp = new indexes_1.CreateIndexOperation(db, name, {\n          __safeContent__: 1\n        }, {});\n        await new Promise((resolve, reject) => {\n          createIndexOp.execute(server, session, err => err ? reject(err) : resolve());\n        });\n      }\n      return coll;\n    })().then(coll => callback(undefined, coll), err => callback(err));\n  }\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      const db = this.db;\n      const name = this.name;\n      const options = this.options;\n      const done = err => {\n        if (err) {\n          return reject(err);\n        }\n        resolve(new collection_1.Collection(db, name, options));\n      };\n      const cmd = {\n        create: name\n      };\n      for (const n in options) {\n        if (options[n] != null && typeof options[n] !== 'function' && !ILLEGAL_COMMAND_FIELDS.has(n)) {\n          cmd[n] = options[n];\n        }\n      }\n      // otherwise just execute the command\n      super.executeCommand(server, session, cmd, done);\n    });\n  }\n}\nexports.CreateCollectionOperation = CreateCollectionOperation;\n(0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n//# sourceMappingURL=create_collection.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}