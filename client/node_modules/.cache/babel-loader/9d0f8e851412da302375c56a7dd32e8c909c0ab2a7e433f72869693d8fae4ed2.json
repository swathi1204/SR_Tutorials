{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Logger = exports.LoggerLevel = void 0;\nconst util_1 = require(\"util\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\n// Filters for classes\nconst classFilters = {};\nlet filteredClasses = {};\nlet level;\n// Save the process id\nconst pid = process.pid;\n// current logger\n// eslint-disable-next-line no-console\nlet currentLogger = console.warn;\n/** @public */\nexports.LoggerLevel = Object.freeze({\n  ERROR: 'error',\n  WARN: 'warn',\n  INFO: 'info',\n  DEBUG: 'debug',\n  error: 'error',\n  warn: 'warn',\n  info: 'info',\n  debug: 'debug'\n});\n/**\n * @public\n * @deprecated This logger is unused and will be removed in the next major version.\n */\nclass Logger {\n  /**\n   * Creates a new Logger instance\n   *\n   * @param className - The Class name associated with the logging instance\n   * @param options - Optional logging settings\n   */\n  constructor(className, options) {\n    options = options !== null && options !== void 0 ? options : {};\n    // Current reference\n    this.className = className;\n    // Current logger\n    if (!(options.logger instanceof Logger) && typeof options.logger === 'function') {\n      currentLogger = options.logger;\n    }\n    // Set level of logging, default is error\n    if (options.loggerLevel) {\n      level = options.loggerLevel || exports.LoggerLevel.ERROR;\n    }\n    // Add all class names\n    if (filteredClasses[this.className] == null) {\n      classFilters[this.className] = true;\n    }\n  }\n  /**\n   * Log a message at the debug level\n   *\n   * @param message - The message to log\n   * @param object - Additional meta data to log\n   */\n  debug(message, object) {\n    if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {\n      const dateTime = new Date().getTime();\n      const msg = (0, util_1.format)('[%s-%s:%s] %s %s', 'DEBUG', this.className, pid, dateTime, message);\n      const state = {\n        type: exports.LoggerLevel.DEBUG,\n        message,\n        className: this.className,\n        pid,\n        date: dateTime\n      };\n      if (object) state.meta = object;\n      currentLogger(msg, state);\n    }\n  }\n  /**\n   * Log a message at the warn level\n   *\n   * @param message - The message to log\n   * @param object - Additional meta data to log\n   */\n  warn(message, object) {\n    if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {\n      const dateTime = new Date().getTime();\n      const msg = (0, util_1.format)('[%s-%s:%s] %s %s', 'WARN', this.className, pid, dateTime, message);\n      const state = {\n        type: exports.LoggerLevel.WARN,\n        message,\n        className: this.className,\n        pid,\n        date: dateTime\n      };\n      if (object) state.meta = object;\n      currentLogger(msg, state);\n    }\n  }\n  /**\n   * Log a message at the info level\n   *\n   * @param message - The message to log\n   * @param object - Additional meta data to log\n   */\n  info(message, object) {\n    if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {\n      const dateTime = new Date().getTime();\n      const msg = (0, util_1.format)('[%s-%s:%s] %s %s', 'INFO', this.className, pid, dateTime, message);\n      const state = {\n        type: exports.LoggerLevel.INFO,\n        message,\n        className: this.className,\n        pid,\n        date: dateTime\n      };\n      if (object) state.meta = object;\n      currentLogger(msg, state);\n    }\n  }\n  /**\n   * Log a message at the error level\n   *\n   * @param message - The message to log\n   * @param object - Additional meta data to log\n   */\n  error(message, object) {\n    if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {\n      const dateTime = new Date().getTime();\n      const msg = (0, util_1.format)('[%s-%s:%s] %s %s', 'ERROR', this.className, pid, dateTime, message);\n      const state = {\n        type: exports.LoggerLevel.ERROR,\n        message,\n        className: this.className,\n        pid,\n        date: dateTime\n      };\n      if (object) state.meta = object;\n      currentLogger(msg, state);\n    }\n  }\n  /** Is the logger set at info level */\n  isInfo() {\n    return level === exports.LoggerLevel.INFO || level === exports.LoggerLevel.DEBUG;\n  }\n  /** Is the logger set at error level */\n  isError() {\n    return level === exports.LoggerLevel.ERROR || level === exports.LoggerLevel.INFO || level === exports.LoggerLevel.DEBUG;\n  }\n  /** Is the logger set at error level */\n  isWarn() {\n    return level === exports.LoggerLevel.ERROR || level === exports.LoggerLevel.WARN || level === exports.LoggerLevel.INFO || level === exports.LoggerLevel.DEBUG;\n  }\n  /** Is the logger set at debug level */\n  isDebug() {\n    return level === exports.LoggerLevel.DEBUG;\n  }\n  /** Resets the logger to default settings, error and no filtered classes */\n  static reset() {\n    level = exports.LoggerLevel.ERROR;\n    filteredClasses = {};\n  }\n  /** Get the current logger function */\n  static currentLogger() {\n    return currentLogger;\n  }\n  /**\n   * Set the current logger function\n   *\n   * @param logger - Custom logging function\n   */\n  static setCurrentLogger(logger) {\n    if (typeof logger !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Current logger must be a function');\n    }\n    currentLogger = logger;\n  }\n  /**\n   * Filter log messages for a particular class\n   *\n   * @param type - The type of filter (currently only class)\n   * @param values - The filters to apply\n   */\n  static filter(type, values) {\n    if (type === 'class' && Array.isArray(values)) {\n      filteredClasses = {};\n      values.forEach(x => filteredClasses[x] = true);\n    }\n  }\n  /**\n   * Set the current log level\n   *\n   * @param newLevel - Set current log level (debug, warn, info, error)\n   */\n  static setLevel(newLevel) {\n    if (newLevel !== exports.LoggerLevel.INFO && newLevel !== exports.LoggerLevel.ERROR && newLevel !== exports.LoggerLevel.DEBUG && newLevel !== exports.LoggerLevel.WARN) {\n      throw new error_1.MongoInvalidArgumentError(`Argument \"newLevel\" should be one of ${(0, utils_1.enumToString)(exports.LoggerLevel)}`);\n    }\n    level = newLevel;\n  }\n}\nexports.Logger = Logger;\n//# sourceMappingURL=logger.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}